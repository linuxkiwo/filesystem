var loadApp = function (path, configPath, name) {
	/*
	 * Esta libreria se encarga:
	 * -Cargar el fichero de cofiguración
	 * -Generar los string con todos los modulos
	 *  que se tienen que importar según los plugins que tenga el usuario o
	 *  según que se reciva por argumento al llamar al programa.
	 *
	 * -Cuando genere los script mueve todos los archivos a la carpeta de .buffer
	 *  para cuando se cierre la app borrarlos y nunca afectar a los archivos
	 *  orifinales
	*/
	const fs = require('fs');
	this.path = path;
	this.homeDir ='';
	this.configPath = this.path + "/" +configPath;
	this.ready = [false, false];
	this.ProgramName = name;
	this.css = '';
	this.jsInit = '';
	this.jsEnd = '';
	this.filesToRead = [];
	this.encodingExtensionsFile = ['js', 'css', 'html']
	this.__loadCss = (css, where = 'css/') => {
		for (let s of css)
				this.css += `<link rel="stylesheet" href="${where}${s}.css">`;
	};
	this.__loadPlugins = (obj) => {
		for (let o of obj) {
			if(!o["load_default"]) continue;
			if (o["difference_between_front_and_back"]){
				let name = (o["difference_between_front_and_back"] === true) ? "{Render}" : "{ " + o["difference_between_front_and_back"][1] + "}";
				let where  = (o["at_init"]) ? "jsInit" : "jsEnd";
					this[where] += `const ${name} = require('${o["name"].toLowerCase()}');`;
			}
			else js += `const ${o["name"]} = require('${o["name"]}');`;
			if (o["style"])
				this.__loadCss(o["style"], `../node_modules/${o["name"].toLowerCase()}/`);
		}
	};
	this.__updateFiles = () => {
		for (let f of this.filesToRead){
			fs.readFile(f, 'utf-8', (err, data) => {
				if (err) return console.error(err)
				let change = data.match(/[#][{](\w*)[}]/g),
					dst = f.replace('/dist/public', '/.buffer');
				if (change){
					for (let i of change){
						let par = i.replace('#{', '').replace('}', '');
						data = data.replace(i, this[par]);
					}
				}
				fs.writeFile(dst, data, (err) => {
					if (err) return console.err(err);
				});
			});
		}
	};
	this.__getJumpBack = (str) => {
		/*
		 * Método encargado de crear el absoluto a través del relativo.
		 * recive la localización inicial junto con el camino relativo
		 * calcula cuantos saltos a atrás tiene que dar y genera el
		 * string con la ruta correcta
		*/
		let steps = str.match(/\/\.{2}/g).length,
			path = str.split("/"),
			toJoin = path.indexOf("..");
		path.splice(toJoin-1, steps+1);
		return path.join("/");
	}
	this.__copyInBuffer = (src, dst) => {
		/*
		 * Hace una réplica en .buffer de la carpeta de dist para
		 * que al cargar los elemementos en los que se permite la
		 * personalización del usuario, nunca afecte al archivo origen
		 * Esta carpeta debería ser eliminada cuando la app se cierre
		*/
		if (dst.indexOf("..") !== -1) dst = this.__getJumpBack(dst);
		try{fs.mkdirSync(dst, '0755');}
		catch (e) {
			if (e.errno !== -17)
				console.error(e)
		}
		fs.readdir(src, (err, dir) => {
			for (let i = 0; i<dir.length; i++){
				if (fs.lstatSync(src + dir[i]).isFile()){
					let ext = dir[i].split(".").splice(-1)[0];
					if (this.encodingExtensionsFile.indexOf(ext) !== -1 && ext !== 'map') 
						this.filesToRead.push(src + dir[i]);
					else
						fs.createReadStream(src + dir[i]).pipe(fs.createWriteStream(dst +"/"+ dir[i]));
				}
				else if (fs.lstatSync(src + dir[i]).isDirectory())
					fs.mkdir(dst +"/"+dir[i], '0755', (e)=>{
						if (e) if (e.errno !== -17) console.error(e); // si hay un error y e es distinto de -17 (la carpeta ya existe) se imprime el error
							this.__copyInBuffer((src + dir[i] + '/'), dst +"/"+ dir[i]);
					});
			}
			this.ready[0] = true;
			if (this.ready[0] && this.ready[1]){
				this.__updateFiles();
				this.ready[0] = false;
			}
		});
	};
	//constructor
	this.__secuence = ((e) => {
		//llammamos a __copyInBuffer
		this.__copyInBuffer(this.path+"/public/", this.path +'/../../../.buffer');
		//leemos el fichero de configuración
		fs.readFile(this.configPath, 'utf-8', (err, data)=>{
			if (err) return console.error(err);
			let filesToReplace = ['index.html', 'js/main.js'],
				scope = {}
			scope.css = ''; scope.js = '';
			config = JSON.parse(data);
			//Primero cargamos el nombre del usuario
			this.homeDir=`/home/${config["name"]}/`;			
			if (config[this.ProgramName]){
				//Cargamos los css personales de haberlos			
				if (config[this.ProgramName]["style"]) 
					this.__loadCss(config[this.ProgramName]["style"]);
				//Después se mira si tiene algún plugin y si lo tiene que cargar
				if (config[this.ProgramName]["pluggins"].length >=1) this.__loadPlugins(config[this.ProgramName]["pluggins"]);
				this.ready[1] = true;
			}
			//Si ya han terminado ambos metodos asyncronicos, se llama  this.update
			if (this.ready[0] && this.ready[1]){
				this.__updateFiles();
				this.ready[1] = false;
			}
		});
	})();
	//destructor
	this.clearBuffer = (path = this.path+ "/../.buffer/") => {
		fs.readdir(path, (err, file) => {
			if (file.length == 0)
				fs.rmdir(path, (e) => {if (e) console.log(e);});
			for (f of file){
				if (fs.lstatSync(`${path}${f}`).isFile())
					fs.unlink(`${path}${f}`, (e) => {
						if (e) console.log(e);
					});
				else if(fs.lstatSync(`${path}${f}`).isDirectory())
					this.clearBuffer(`${path}${f}/`);					
			}
			fs.rmdir(path, (e) => {if (e) this.clearBuffer(path)});

		});
	};
	this.pathToLoad = this.__getJumpBack(`${this.path}/../.buffer`);
}
module.exports = exports = loadApp;

