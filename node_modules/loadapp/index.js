var loadApp = function (path, configPath, name) {
	/*
	 * Esta libreria se encarga:
	 * -Cargar el fichero de cofiguración
	 * -Generar los string con todos los modulos
	 *  que se tienen que importar según los plugins que tenga el usuario o
	 *  según que se reciva por argumento al llamar al programa.
	 *
	 * -Cuando genere los script mueve todos los archivos a la carpeta de .buffer
	 *  para cuando se cierre la app borrarlos y nunca afectar a los archivos
	 *  orifinales
	*/
	const fs = require('fs');
	this.path = path;
	this.homeDir ='';
	this.configPath = this.path + "/" +configPath;
	this.ready = [false, false];
	this.ProgramName = name;
	this.__loadCss = (css, where = 'css/') => {
		for (let s of css)
				this.css += `<link rel="stylesheet" href="${where}${s}">`;
	};
	this.__loadPlugins = (obj) => {
		for (let o of obj) {
			if(!o["load_default"]) continue;
			if (o["difference_between_front_and_back"]){
				let name = (o["difference_between_front_and_back"] === true) ? "{Render}" : "{ " + o["difference_between_front_and_back"][1] + "}";  
				this.js += `const ${name} = require('${o["name"]}');`;
			}
			else js += `const ${o["name"]} = require('${o["name"]}');`;
			if (o["style"])
				this.__loadCss(o["style"], "../node_modules/");				
		}	
	};
	this.__updateFiles = () => {
		let filesToReplace = ['index.html', 'js/main.js'];
		for (let f of filesToReplace)
			fs.readFile(`${this.path}/dist/${f}`, 'utf-8', (err, data) => {
				let change = data.match(/[#][{](\w*)[}]/)[0],
					par = change.replace('#{', '').replace('}', '');
				data = data.replace()
				data = data.replace(change, this[par]);
				fs.wrtite(`${this.path}/.buffer/${f}`, data, (err) => {
					if (err) return console.log(err);
				})
			});
	};
	this.__getJumpBack = (str) => {
		/*
		 * Método encargado de crear el absoluto a través del relativo.
		 * recive la localización inicial junto con el camino relativo
		 * calcula cuantos saltos a atrás tiene que dar y genera el
		 * string con la ruta correcta
		*/
		let steps = str.match(/\/\.{2}/g).length,
			path = str.split("/"),
			toJoin = path.indexOf("..");
		path.splice(toJoin-1, steps+1);
		return path.join("/");
	}
	this.__copyInBuffer = (src, dst) => {
		/*
		 * Hace una réplica en .buffer de la carpeta de dist para
		 * que al cargar los elemementos en los que se permite la
		 * personalización del usuario, nunca afecte al archivo origen
		 * Esta carpeta debería ser eliminada cuando la app se cierre
		*/
		if (dst.indexOf("..") !== -1)
			dst = this.__getJumpBack(dst);
		try{
			fs.mkdirSync(dst, '0755');
		}
		catch (e) {
			if (e.errno !== -17)
				console.log(e)
		}
		fs.readdir(src, (err, dir) => {
			for (let i = 0; i<dir.length; i++){
				if (fs.lstatSync(src + dir[i]).isFile())
					fs.createReadStream(src + dir[i]).pipe(fs.createWriteStream(dst +"/"+ dir[i]));
				else if (fs.lstatSync(src + dir[i]).isDirectory())
					fs.mkdir(dst +"/"+dir[i], '0755', (e)=>{
						if (e) if (e.errno !== -17) console.log(e); // si hay un error y e es distinto de -17 (la carpeta ya existe) se imprime el error
							this.__copyInBuffer((src + dir[i] + '/'), dst +"/"+ dir[i]);
					});
			}
			this.ready[0] = true;
			if (this.ready[0] && this.ready[1]){
				this.__updateFiles();
				this.ready[0] = false;
			}
		});
	};
	//constructor
	this.__secuence = ((e) => {
		//llammamos a __copyInBuffer
		this.__copyInBuffer(this.path+"/public/", this.path +'/../../../.buffer');
		//leemos el fichero de configuración
		fs.readFile(this.configPath, 'utf-8', (err, data)=>{
			if (err) return console.log(err);
			let filesToReplace = ['index.html', 'js/main.js'],
				scope = {}
			scope.css = ''; scope.js = '';
			config = JSON.parse(data);
			//Primero cargamos el nombre del usuario
			this.homeDir=`/home/${config["name"]}/`;
			if (config[this.ProgramName]){
				//Cargamos los css personales de haberlos			
				if (config[this.ProgramName]["style"]) 
					this.__loadCss(config[this.ProgramName]["style"]);
				//Después se mira si tiene algún plugin y si lo tiene que cargar
				if (config[this.ProgramName]["pluggins"].length >1) this.__loadPlugins(config[this.ProgramName]["pluggins"]);
				this.ready[1] = true;
			}
			//Si ya han terminado ambos metodos asyncronicos, se llama  this.update
			if (this.ready[0] && this.ready[1]){
				this.__updateFiles();
				this.ready[1] = false;
			}
		});
	})();
	//destructor
	this.clearBuffer = (path = this.path+ "/../.buffer/") => {
		fs.readdir(path, (err, file) => {
			if (file.length == 0)
				fs.rmdir(path, (e) => {if (e) console.log(e);});
			for (f of file){
				if (fs.lstatSync(`${path}${f}`).isFile())
					fs.unlink(`${path}${f}`, (e) => {
						if (e) console.log(e);
					});
				else if(fs.lstatSync(`${path}${f}`).isDirectory())
					this.clearBuffer(`${path}${f}/`);					
			}
			fs.rmdir(path, (e) => {if (e) this.clearBuffer(path)});

		});
	};
}
module.exports = exports = loadApp;

